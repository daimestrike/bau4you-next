// –ü—Ä–æ–∫—Å–∏-–∫–ª–∏–µ–Ω—Ç –¥–ª—è Supabase —á–µ—Ä–µ–∑ VPS
const VPS_URL = 'https://api.bau4you.co'
const PROXY_BASE_URL = `${VPS_URL}/api/sb`

interface SupabaseAuthResponse {
  access_token?: string
  refresh_token?: string
  user?: any
  error?: any
}

interface SupabaseResponse<T = any> {
  data: T
  error: any
  count?: number
  status: number
  statusText: string
}

class SupabaseProxyClient {
  private accessToken: string | null = null
  private refreshToken: string | null = null

  constructor() {
    // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ç–æ–∫–µ–Ω—ã –∏–∑ localStorage –ø—Ä–∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏
    if (typeof window !== 'undefined') {
      this.accessToken = localStorage.getItem('sb-access-token')
      this.refreshToken = localStorage.getItem('sb-refresh-token')
    }
  }

  // –ë–∞–∑–æ–≤—ã–π –º–µ—Ç–æ–¥ –¥–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –∑–∞–ø—Ä–æ—Å–æ–≤
  private async makeRequest(
    path: string, 
    options: RequestInit = {},
    useServiceRole = false
  ): Promise<Response> {
    const url = `${PROXY_BASE_URL}/${path}`
    
    const headers = new Headers(options.headers)
    
    // –î–æ–±–∞–≤–ª—è–µ–º –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—é –µ—Å–ª–∏ –µ—Å—Ç—å —Ç–æ–∫–µ–Ω
    if (this.accessToken && !useServiceRole) {
      headers.set('authorization', `Bearer ${this.accessToken}`)
    }
    
    // –§–ª–∞–≥ –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è service role (–¥–ª—è –∞–¥–º–∏–Ω—Å–∫–∏—Ö –æ–ø–µ—Ä–∞—Ü–∏–π)
    if (useServiceRole) {
      headers.set('x-use-service-role', 'true')
    }
    
    // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º Content-Type –¥–ª—è JSON –µ—Å–ª–∏ –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω
    if (options.body && !headers.get('content-type')) {
      headers.set('content-type', 'application/json')
    }
    
    console.log(`üîÑ Proxy Request: ${options.method || 'GET'} ${path}`)
    
    const response = await fetch(url, {
      ...options,
      headers
    })
    
    console.log(`üì° Proxy Response: ${response.status} ${response.statusText}`)
    
    return response
  }

  // Auth –º–µ—Ç–æ–¥—ã
  auth = {
    // –í—Ö–æ–¥ –ø–æ email/password
    signInWithPassword: async (credentials: { email: string; password: string }): Promise<SupabaseAuthResponse> => {
      try {
        const response = await this.makeRequest('auth/v1/token?grant_type=password', {
          method: 'POST',
          body: JSON.stringify({
            email: credentials.email,
            password: credentials.password
          })
        })
        
        const responseData = await response.json()
        
        if (responseData.access_token) {
          this.accessToken = responseData.access_token
          this.refreshToken = responseData.refresh_token
          
          // –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ localStorage
          if (typeof window !== 'undefined') {
            localStorage.setItem('sb-access-token', responseData.access_token)
            localStorage.setItem('sb-refresh-token', responseData.refresh_token)
            localStorage.setItem('sb-user', JSON.stringify(responseData.user))
          }
          
          // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –≤ —Ñ–æ—Ä–º–∞—Ç–µ Supabase
          return {
            access_token: responseData.access_token,
            refresh_token: responseData.refresh_token,
            user: responseData.user,
            error: null
          }
        } else if (responseData.error) {
          return {
            error: responseData.error
          }
        } else {
          return {
            error: { message: '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏' }
          }
        }
      } catch (error) {
        console.error('‚ùå Sign in error:', error)
        return {
          error: { message: error instanceof Error ? error.message : '–û—à–∏–±–∫–∞ —Å–µ—Ç–∏' }
        }
      }
    },

    // –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è
    signUp: async (credentials: { email: string; password: string; options?: any }): Promise<SupabaseAuthResponse> => {
      try {
        const response = await this.makeRequest('auth/v1/signup', {
          method: 'POST',
          body: JSON.stringify({
            email: credentials.email,
            password: credentials.password,
            data: credentials.options?.data || {}
          })
        })
        
        const responseData = await response.json()
        console.log('üìä SignUp Response Data:', responseData)
        
        if (responseData.access_token) {
          this.accessToken = responseData.access_token
          this.refreshToken = responseData.refresh_token
          
          // –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ localStorage
          if (typeof window !== 'undefined') {
            localStorage.setItem('sb-access-token', responseData.access_token)
            localStorage.setItem('sb-refresh-token', responseData.refresh_token)
            localStorage.setItem('sb-user', JSON.stringify(responseData.user))
          }
          
          // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –≤ —Ñ–æ—Ä–º–∞—Ç–µ Supabase
          return {
            access_token: responseData.access_token,
            refresh_token: responseData.refresh_token,
            user: responseData.user,
            error: null
          }
        } else {
          // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –¥–∞–Ω–Ω—ã–µ –∫–∞–∫ –µ—Å—Ç—å, –µ—Å–ª–∏ –Ω–µ—Ç —Ç–æ–∫–µ–Ω–∞ (–º–æ–∂–µ—Ç –±—ã—Ç—å —Ç—Ä–µ–±—É–µ—Ç—Å—è –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ email)
          return {
            user: responseData.user,
            error: responseData.error || null
          }
        }
      } catch (error) {
        console.error('‚ùå Sign up error:', error)
        return { 
          error: { message: error instanceof Error ? error.message : '–û—à–∏–±–∫–∞ —Å–µ—Ç–∏' }
        }
      }
    },

    // –í—ã—Ö–æ–¥
    signOut: async (options?: { scope?: 'global' | 'local' }): Promise<{ error?: any }> => {
      try {
        // –ï—Å–ª–∏ scope –Ω–µ 'local', –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –∑–∞–ø—Ä–æ—Å –Ω–∞ —Å–µ—Ä–≤–µ—Ä
        if (options?.scope !== 'local' && this.accessToken) {
          await this.makeRequest('auth/v1/logout', {
            method: 'POST'
          })
        }
        
        // –û—á–∏—â–∞–µ–º —Ç–æ–∫–µ–Ω—ã
        this.accessToken = null
        this.refreshToken = null
        
        if (typeof window !== 'undefined') {
          localStorage.removeItem('sb-access-token')
          localStorage.removeItem('sb-refresh-token')
          localStorage.removeItem('sb-user')
        }
        
        return {}
      } catch (error) {
        console.error('‚ùå Sign out error:', error)
        return { error }
      }
    },

    // –ü–æ–ª—É—á–µ–Ω–∏–µ —Ç–µ–∫—É—â–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    getUser: async (): Promise<{ user: any, error?: any }> => {
      try {
        if (!this.accessToken) {
          return { user: null, error: { message: 'No access token' } }
        }
        
        const response = await this.makeRequest('auth/v1/user', {
          method: 'GET'
        })
        
        const data = await response.json()
        return { user: data, error: response.ok ? null : data }
      } catch (error) {
        console.error('‚ùå Get user error:', error)
        return { user: null, error }
      }
    },

    // –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–µ—Å—Å–∏–∏
    getSession: async (): Promise<{ session: any, error?: any }> => {
      try {
        if (!this.accessToken) {
          return { session: null, error: null }
        }
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤–∞–ª–∏–¥–Ω–æ—Å—Ç—å —Ç–æ–∫–µ–Ω–∞
        const userResponse = await this.auth.getUser()
        if (userResponse.error) {
          return { session: null, error: userResponse.error }
        }
        
        const session = {
          access_token: this.accessToken,
          refresh_token: this.refreshToken,
          user: userResponse.user,
          expires_at: null // TODO: –º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –æ–±—Ä–∞–±–æ—Ç–∫—É –∏—Å—Ç–µ—á–µ–Ω–∏—è
        }
        
        return { session, error: null }
      } catch (error) {
        console.error('‚ùå Get session error:', error)
        return { session: null, error }
      }
    },

    // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ç–æ–∫–µ–Ω–∞
    refreshSession: async (): Promise<SupabaseAuthResponse> => {
      try {
        if (!this.refreshToken) {
          throw new Error('No refresh token')
        }
        
        const response = await this.makeRequest('auth/v1/token?grant_type=refresh_token', {
          method: 'POST',
          body: JSON.stringify({
            refresh_token: this.refreshToken
          })
        })
        
        const data = await response.json()
        
        if (data.access_token) {
          this.accessToken = data.access_token
          this.refreshToken = data.refresh_token
          
          if (typeof window !== 'undefined') {
            localStorage.setItem('sb-access-token', data.access_token)
            localStorage.setItem('sb-refresh-token', data.refresh_token)
          }
        }
        
        return data
      } catch (error) {
        console.error('‚ùå Refresh session error:', error)
        return { error }
      }
    },

    // –ü–æ–¥–ø–∏—Å–∫–∞ –Ω–∞ –∏–∑–º–µ–Ω–µ–Ω–∏—è —Å–æ—Å—Ç–æ—è–Ω–∏—è –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏ (–∑–∞–≥–ª—É—à–∫–∞ –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏)
    onAuthStateChange: (callback: (event: string, session: any) => void) => {
      // –î–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –æ–±—ä–µ–∫—Ç —Å –º–µ—Ç–æ–¥–æ–º unsubscribe
      // –í —Ä–µ–∞–ª—å–Ω–æ–π —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ –∑–¥–µ—Å—å –±—ã–ª –±—ã WebSocket –∏–ª–∏ EventSource
      console.log('üîî onAuthStateChange called (proxy mode)')
      
      // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç–µ–∫—É—â—É—é —Å–µ—Å—Å–∏—é –ø—Ä–∏ –ø–æ–¥–ø–∏—Å–∫–µ
      if (typeof window !== 'undefined') {
        setTimeout(async () => {
          const { session } = await this.auth.getSession()
          if (session) {
            callback('SIGNED_IN', session)
          } else {
            callback('SIGNED_OUT', null)
          }
        }, 100)
      }
      
      return {
        data: {
          subscription: {
            unsubscribe: () => {
              console.log('üîï Auth state change unsubscribed')
            }
          }
        }
      }
    }
  }

  // Database –º–µ—Ç–æ–¥—ã
  from = (table: string) => {
    return new SupabaseQueryBuilder(table, this.makeRequest.bind(this))
  }

  // Storage –º–µ—Ç–æ–¥—ã
  storage = {
    from: (bucket: string) => {
      return new SupabaseStorageClient(bucket, this.makeRequest.bind(this))
    }
  }
}

// Query Builder –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å —Ç–∞–±–ª–∏—Ü–∞–º–∏
class SupabaseQueryBuilder {
  private table: string
  private makeRequest: (path: string, options?: RequestInit, useServiceRole?: boolean) => Promise<Response>
  private queryParams: URLSearchParams = new URLSearchParams()
  private insertValues: any
  private updateValues: any
  private operation: string = 'select'
  private selectColumns = '*'
  private isSingle: boolean = false
  private isMaybeSingle: boolean = false

  constructor(table: string, makeRequest: (path: string, options?: RequestInit, useServiceRole?: boolean) => Promise<Response>) {
    this.table = table
    this.makeRequest = makeRequest
    this.isSingle = false
    this.isMaybeSingle = false
  }

  select(columns = '*') {
    this.selectColumns = columns
    this.queryParams.set('select', columns)
    return this
  }

  eq(column: string, value: any) {
    this.queryParams.set(column, `eq.${value}`)
    return this
  }

  neq(column: string, value: any) {
    this.queryParams.set(column, `neq.${value}`)
    return this
  }

  gt(column: string, value: any) {
    this.queryParams.set(column, `gt.${value}`)
    return this
  }

  gte(column: string, value: any) {
    this.queryParams.set(column, `gte.${value}`)
    return this
  }

  lt(column: string, value: any) {
    this.queryParams.set(column, `lt.${value}`)
    return this
  }

  lte(column: string, value: any) {
    this.queryParams.set(column, `lte.${value}`)
    return this
  }

  like(column: string, pattern: string) {
    this.queryParams.set(column, `like.${pattern}`)
    return this
  }

  ilike(column: string, pattern: string) {
    this.queryParams.set(column, `ilike.${pattern}`)
    return this
  }

  or(query: string) {
    this.queryParams.set('or', query)
    return this
  }

  order(column: string, options: { ascending?: boolean } = {}) {
    const direction = options.ascending === false ? 'desc' : 'asc'
    this.queryParams.set('order', `${column}.${direction}`)
    return this
  }

  limit(count: number) {
    this.queryParams.set('limit', count.toString())
    return this
  }

  range(from: number, to: number) {
    this.queryParams.set('offset', from.toString())
    this.queryParams.set('limit', (to - from + 1).toString())
    return this
  }

  single() {
    this.queryParams.set('limit', '1')
    // –î–æ–±–∞–≤–ª—è–µ–º order –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é, –µ—Å–ª–∏ –Ω–µ —É–∫–∞–∑–∞–Ω
    if (!this.queryParams.has('order')) {
      this.queryParams.set('order', 'id')
    }
    this.isSingle = true
    this.isMaybeSingle = false
    return this
  }

  maybeSingle() {
    this.queryParams.set('limit', '1')
    // –î–æ–±–∞–≤–ª—è–µ–º order –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é, –µ—Å–ª–∏ –Ω–µ —É–∫–∞–∑–∞–Ω
    if (!this.queryParams.has('order')) {
      this.queryParams.set('order', 'id')
    }
    this.isSingle = true
    this.isMaybeSingle = true
    return this
  }

  // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏
  then(onFulfilled?: any, onRejected?: any) {
    return this.execute().then(onFulfilled, onRejected)
  }

  async execute(): Promise<SupabaseResponse> {
    try {
      // –í—ã–ø–æ–ª–Ω—è–µ–º —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â—É—é –æ–ø–µ—Ä–∞—Ü–∏—é
      if (this.operation === 'insert') {
        return this.executeInsert()
      }
      if (this.operation === 'update') {
        return this.executeUpdate()
      }
      
      // –û–±—ã—á–Ω—ã–π SELECT –∑–∞–ø—Ä–æ—Å
      const path = `rest/v1/${this.table}?${this.queryParams.toString()}`
      const response = await this.makeRequest(path, { method: 'GET' })
      
      const data = await response.json()
      
      // –ï—Å–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è single() –∏–ª–∏ maybeSingle(), –∏–∑–≤–ª–µ–∫–∞–µ–º –ø–µ—Ä–≤—ã–π —ç–ª–µ–º–µ–Ω—Ç –∏–∑ –º–∞—Å—Å–∏–≤–∞
      let resultData = data
      if (this.isSingle && response.ok && Array.isArray(data)) {
        if (data.length === 0) {
          if (this.isMaybeSingle) {
            // maybeSingle() –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç null, –µ—Å–ª–∏ –∑–∞–ø–∏—Å–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã
            resultData = null
          } else {
            // single() –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –æ—à–∏–±–∫—É, –µ—Å–ª–∏ –∑–∞–ø–∏—Å–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã
            return {
              data: null,
              error: { message: 'No rows found', code: 'PGRST116' },
              status: 406,
              statusText: 'Not Acceptable'
            }
          }
        } else {
          resultData = data[0]
        }
      }
      
      return {
        data: response.ok ? resultData : null,
        error: response.ok ? null : data,
        status: response.status,
        statusText: response.statusText
      }
    } catch (error) {
      console.error('execute error:', error)
      return {
        data: null,
        error: {
          message: error instanceof Error ? error.message : 'Unknown error occurred',
          code: 'PROXY_ERROR', 
          details: error
        },
        status: 500,
        statusText: 'Internal Error'
      }
    }
  }

  // –ú–µ—Ç–æ–¥—ã –¥–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –∑–∞–ø—Ä–æ—Å–æ–≤
  insert(values: any | any[]) {
    this.insertValues = values
    this.operation = 'insert'
    return this
  }

  async executeInsert(): Promise<SupabaseResponse> {
    try {
      let path = `rest/v1/${this.table}`
      if (this.queryParams.has('select')) {
        path += `?${this.queryParams.toString()}`
      }
      
      const response = await this.makeRequest(path, {
        method: 'POST',
        body: JSON.stringify(this.insertValues)
      })
      
      // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –æ—Ç–≤–µ—Ç –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Å—Ç–∞—Ç—É—Å–∞
      let data = null
      if (response.status === 204) {
        // 204 No Content - —É—Å–ø–µ—à–Ω–∞—è –æ–ø–µ—Ä–∞—Ü–∏—è –±–µ–∑ –≤–æ–∑–≤—Ä–∞—Ç–∞ –¥–∞–Ω–Ω—ã—Ö
        data = this.isSingle ? {} : []
      } else if (response.status === 201 || response.status === 200) {
        // 201 Created –∏–ª–∏ 200 OK - —á–∏—Ç–∞–µ–º —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ
        const text = await response.text()
        if (text) {
          try {
            data = JSON.parse(text)
          } catch (parseError) {
            console.warn('Failed to parse response as JSON:', text)
            data = text
          }
        }
      } else {
        // –î–ª—è –æ—à–∏–±–æ–∫ –ø—ã—Ç–∞–µ–º—Å—è –ø—Ä–æ—á–∏—Ç–∞—Ç—å body
        const text = await response.text()
        if (text) {
          try {
            data = JSON.parse(text)
          } catch (parseError) {
            console.warn('Failed to parse error response as JSON:', text)
            data = { message: text }
          }
        } else {
          data = { message: `HTTP ${response.status}: ${response.statusText}` }
        }
      }
      
      // –ï—Å–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è single() –∏–ª–∏ maybeSingle(), –∏–∑–≤–ª–µ–∫–∞–µ–º –ø–µ—Ä–≤—ã–π —ç–ª–µ–º–µ–Ω—Ç –∏–∑ –º–∞—Å—Å–∏–≤–∞
      let resultData = data
      if (this.isSingle && response.ok && Array.isArray(data)) {
        if (data.length === 0) {
          if (this.isMaybeSingle) {
            resultData = null
          } else {
            return {
              data: null,
              error: { message: 'No rows found', code: 'PGRST116' },
              status: 406,
              statusText: 'Not Acceptable'
            }
          }
        } else {
          resultData = data[0]
        }
      }
      
      return {
        data: response.ok ? resultData : null,
        error: response.ok ? null : data,
        status: response.status,
        statusText: response.statusText
      }
    } catch (error) {
      console.error('executeInsert error:', error)
      return {
        data: null,
        error: {
          message: error instanceof Error ? error.message : 'Unknown error occurred',
          code: 'PROXY_ERROR',
          details: error
        },
        status: 500,
        statusText: 'Internal Error'
      }
    }
  }

  update(values: any) {
    this.updateValues = values
    this.operation = 'update'
    return this
  }

  async executeUpdate(): Promise<SupabaseResponse> {
    try {
      const path = `rest/v1/${this.table}?${this.queryParams.toString()}`
      const response = await this.makeRequest(path, {
        method: 'PATCH',
        body: JSON.stringify(this.updateValues)
      })
      
      // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –æ—Ç–≤–µ—Ç –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Å—Ç–∞—Ç—É—Å–∞
      let data = null
      if (response.status === 204) {
        // 204 No Content - —É—Å–ø–µ—à–Ω–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –±–µ–∑ –≤–æ–∑–≤—Ä–∞—Ç–∞ –¥–∞–Ω–Ω—ã—Ö
        // –í–æ–∑–≤—Ä–∞—â–∞–µ–º null –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏ —Å Supabase –∫–ª–∏–µ–Ω—Ç–æ–º
        data = null
      } else if (response.status !== 200) {
        // –î–ª—è –æ—à–∏–±–æ–∫ –ø—ã—Ç–∞–µ–º—Å—è –ø—Ä–æ—á–∏—Ç–∞—Ç—å body
        const text = await response.text()
        if (text) {
          try {
            data = JSON.parse(text)
          } catch (parseError) {
            console.warn('Failed to parse error response as JSON:', text)
            data = { message: text }
          }
        } else {
          data = { message: `HTTP ${response.status}: ${response.statusText}` }
        }
      } else {
        // 200 OK - —á–∏—Ç–∞–µ–º —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ
        const text = await response.text()
        if (text) {
          try {
            data = JSON.parse(text)
          } catch (parseError) {
            console.warn('Failed to parse response as JSON:', text)
            data = text
          }
        }
      }
      
      // –ï—Å–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è single() –∏–ª–∏ maybeSingle(), –∏–∑–≤–ª–µ–∫–∞–µ–º –ø–µ—Ä–≤—ã–π —ç–ª–µ–º–µ–Ω—Ç –∏–∑ –º–∞—Å—Å–∏–≤–∞
      let resultData = data
      if (this.isSingle && response.ok && Array.isArray(data)) {
        if (data.length === 0) {
          if (this.isMaybeSingle) {
            resultData = null
          } else {
            return {
              data: null,
              error: { message: 'No rows found', code: 'PGRST116' },
              status: 406,
              statusText: 'Not Acceptable'
            }
          }
        } else {
          resultData = data[0]
        }
      }
      
      return {
        data: response.ok ? resultData : null,
        error: response.ok ? null : data,
        status: response.status,
        statusText: response.statusText
      }
    } catch (error) {
      console.error('executeUpdate error:', error)
      return {
        data: null,
        error: {
          message: error instanceof Error ? error.message : 'Unknown error occurred',
          code: 'PROXY_ERROR',
          details: error
        },
        status: 500,
        statusText: 'Internal Error'
      }
    }
  }

  async delete(): Promise<SupabaseResponse> {
    try {
      const path = `rest/v1/${this.table}?${this.queryParams.toString()}`
      const response = await this.makeRequest(path, { method: 'DELETE' })
      
      const data = response.status !== 204 ? await response.json() : null
      
      return {
        data: response.ok ? data : null,
        error: response.ok ? null : data,
        status: response.status,
        statusText: response.statusText
      }
    } catch (error) {
      console.error('delete error:', error)
      return {
        data: null,
        error: {
          message: error instanceof Error ? error.message : 'Unknown error occurred',
          code: 'PROXY_ERROR',
          details: error
        },
        status: 500,
        statusText: 'Internal Error'
      }
    }
  }
}

// Storage Client –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å —Ñ–∞–π–ª–∞–º–∏
class SupabaseStorageClient {
  private bucket: string
  private makeRequest: (path: string, options?: RequestInit, useServiceRole?: boolean) => Promise<Response>

  constructor(bucket: string, makeRequest: (path: string, options?: RequestInit, useServiceRole?: boolean) => Promise<Response>) {
    this.bucket = bucket
    this.makeRequest = makeRequest
  }

  async upload(path: string, file: File | Blob, options: any = {}) {
    try {
      const formData = new FormData()
      formData.append('file', file)
      
      const response = await this.makeRequest(`storage/v1/object/${this.bucket}/${path}`, {
        method: 'POST',
        body: formData
      })
      
      const data = await response.json()
      
      return {
        path: response.ok ? data.path : null,
        error: response.ok ? null : data
      }
    } catch (error) {
      return { path: null, error }
    }
  }

  async download(path: string) {
    try {
      const response = await this.makeRequest(`storage/v1/object/${this.bucket}/${path}`, {
        method: 'GET'
      })
      
      if (response.ok) {
        const blob = await response.blob()
        return { blob, error: null }
      } else {
        const error = await response.json()
        return { blob: null, error }
      }
    } catch (error) {
      return { blob: null, error }
    }
  }

  getPublicUrl(path: string) {
    return {
      data: {
        publicUrl: `${PROXY_BASE_URL}/storage/v1/object/public/${this.bucket}/${path}`
      }
    }
  }
}

// –°–æ–∑–¥–∞–µ–º –∏ —ç–∫—Å–ø–æ—Ä—Ç–∏—Ä—É–µ–º –µ–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä –∫–ª–∏–µ–Ω—Ç–∞
export const supabaseProxy = new SupabaseProxyClient()
export default supabaseProxy